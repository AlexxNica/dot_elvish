#+PROPERTY: header-args:elvish :tangle rc.elv
#+PROPERTY: header-args :mkdirp yes :comments no 

#+TITLE:  My Elvish config file
#+AUTHOR: Diego Zamboni
#+EMAIL:  diego@zzamboni.org

#+BEGIN_SRC elvish :exports none
  # DO NOT EDIT THIS FILE DIRECTLY
  # This is a file generated from a literate programing source file located at
  # https://github.com/zzamboni/vcsh_elvish/blob/master/.elvish/rc.org.
  # You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+END_SRC

* Introduction

  This is my main config file for [[http://elvish.io][Elvish]].

  This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy
  to explain. See [[file:rc.elv][rc.elv]] for the generated file.

* Paths

  First we set up the executable paths. We set the ~GOPATH~ environment
  variable while we are at it, since we need to use it as part of the
  path.

  #+BEGIN_SRC elvish
    E:GOPATH = ~/Personal/devel/go/
    paths = [
      ~/bin
      ~/Dropbox/Personal/devel/hammerspoon/spoon/bin
      ~/.gem/ruby/2.4.0/bin
      /opt/X11/bin
      /Library/TeX/texbin
      /usr/local/opt/node@6/bin
      /usr/local/bin
      /usr/local/sbin
      /usr/bin
      /bin
      /usr/sbin
      /sbin
      $E:GOPATH/bin    
    ]
  #+END_SRC

* Base modules

  Load the bundled [[https://elvish.io/ref/re.html][re]] module for regular expression functions.

  #+BEGIN_SRC elvish
    use re
  #+END_SRC

  The [[file:lib/prompt_hooks.org][prompt_hooks]] module provides some functions for manipulating the
  before/after command hooks.

  #+BEGIN_SRC elvish
    use prompt_hooks
  #+END_SRC

  The bundled [[https://elvish.io/ref/bundled.html][readline-binding]] module associates some Emacs-like
  keybindings for manipulation of the command line.
  
  #+BEGIN_SRC elvish
    use readline-binding
  #+END_SRC

  I add a couple of keybindings which are missing from the default
  =readline-binding= module.

  #+BEGIN_SRC elvish
    # Alt-backspace to delete word
    edit:insert:binding[Alt-Backspace] = $edit:kill-small-word-left~
    # Alt-d to delete the word under the cursor
    edit:insert:binding[Alt-d] = { edit:move-dot-right-word; edit:kill-word-left }
  #+END_SRC

* Nix package manager

  I use the [[https://nixos.org/nix/][Nix]] package manager on macOS, the [[file:lib/nix.org][nix]] module sets up the
  necessary environment variables.

  #+BEGIN_SRC elvish
    use nix
    nix:multi-user-setup
  #+END_SRC

* Git-related stuff

  The [[file:lib/git.org][git]] module defines some git-related functionality, including a
  wrapper to automatically call =vcsh= when needed.

  #+BEGIN_SRC elvish
    use git
    fn git [@arg]{ git:git_vcsh $@arg }
  #+END_SRC

  We also load the [[file:lib/completer/git.org][completer:git]] module to provide completions for
  git and similar commands. We set the completer to call the =git=
  function defined above, so that it also works when we are in vcsh
  repositories.

  #+BEGIN_SRC elvish
    use completer:git
    edit:arg-completer[git] = [@args]{ completer:git:git-completer $git~ (explode $args[1:]) }
  #+END_SRC

  The [[file:lib/completer/vcsh.org][completer:vcsh]] module provides git-like completion for vcsh.

  #+BEGIN_SRC elvish
    use completer:vcsh
  #+END_SRC

* Prompt theme

  I use the [[file:lib/theme/chain.org][chain]] prompt theme, ported from the fish theme at
  https://github.com/oh-my-fish/theme-chain.

  #+BEGIN_SRC elvish
    use theme:chain
    edit:-prompts-max-wait = 0.01
    theme:chain:setup
  #+END_SRC

* Automatic proxy settings

  When I am in the office, I need to use a proxy to access the
  Internet. For macOS applications, the proxy is set automatically
  using a company-provided PAC file. For the command line variables,
  the [[file:lib/proxy.org][proxy]] module allows me to define a test which determines when
  the proxy should be set, so that the change is done automatically.

  First, we load the module and set the proxy. The
  =proxy:setup_autoset= function adds the =proxy:autoset= function to
  both the pre- and post-command hooks, so that the proxy is
  automatically set/unset as soon as possible, even if the conditions
  change while I am typing a command.

  #+BEGIN_SRC elvish
    use proxy
    proxy:host = "http://proxy.corproot.net:8079"
    proxy:setup_autoset 
  #+END_SRC

  Next, we set the test function. In my case, the =/etc/resolv.conf=
  file contains the ~corproot.net~ domain (set through DHCP) when I'm in
  the corporate network, so I can check for that.

  #+BEGIN_SRC elvish
    proxy:test = { and ?(test -f /etc/resolv.conf) ?(egrep -q '^(search|domain).*corproot.net' /etc/resolv.conf) }
  #+END_SRC

* Long-running-command notifications

  The [[file:lib/long-running-notifications.org][long-running-notifications]] module allows for producing a
  notification when a command takes longer than a certain time to
  finish (by default the period is 10 seconds). The module
  automatically detects when [[https://github.com/julienXX/terminal-notifier][terminal-notifier]] is available on macOS
  and uses it to produce Mac-style notifications, otherwise it prints
  a notification on the terminal.

  #+BEGIN_SRC elvish
    use long-running-notifications
    long-running-notifications:setup
  #+END_SRC

* Directory and command navigation and history

  Elvish comes with built-in location and command history modes. I use
  the new (still experimental) =narrow= module, which allow for more
  customization, including pre- and after- hooks for each of the
  modes. I use the default binding for history mode (~C-r~), but change
  the location mode binding to ~Alt-l~ to avoid conflicting with the binding of
  ~C-l~ to "clear screen" in =readline-binding=. I disable the
  lastcmd binding because it is taken over by the =bang-bang= module
  below.

  #+BEGIN_SRC elvish
    use narrow
    narrow:bind-trigger-keys &location=Alt-l &lastcmd=""
  #+END_SRC

  I have decades of muscle memory using ~!!~ and ~!$~ to insert the last
  command and its last argument, respectively. The [[file:lib/bang-bang.org][bang-bang]] module
  allows me to keep using them.
  
  #+BEGIN_SRC elvish
    use bang-bang
    bang-bang:bind-trigger-keys
  #+END_SRC

  The [[file:lib/dir.org][dir]] module implements a directory history and some related
  functions. I override the built-in ~cd~ command with a function that
  calls =dir:cd= so that any directory changes are kept in the
  history. I also create a top-level wrapper for the =dir:cdb= function,
  which allows changing to the base directory of the argument. The
  module also implements a narrow-based directory history chooser,
  which I bind to ~Alt-i~.

  #+BEGIN_SRC elvish
    use dir
    dir:setup
    edit:insert:binding[Alt-b] = $dir:left-word-or-prev-dir~
    edit:insert:binding[Alt-f] = $dir:right-word-or-next-dir~
    edit:insert:binding[Alt-i] = $dir:history-chooser~
    fn cd [@dir]{ dir:cd $@dir }
    fn cdb [@dir]{ dir:cdb $@dir }
  #+END_SRC

* Aliases

  Elvish does not have built-in alias functionality, but this is
  implemented easily using the [[file:lib/alias.org][alias]] module, which stores the alias
  definitions as functions under =~/.elvish/aliases/= and loads them
  automatically.

  #+BEGIN_SRC elvish
    use alias
  #+END_SRC

* Dynamic terminal title

  The =set-title= function uses the standard ANSI escape sequence for
  setting the terminal title. I add hooks to set the title before and
  after each command, so that the terminal title will show the name of
  the command being executed or the word ~"elvish"~, followed by the
  current path.

  #+BEGIN_SRC elvish
    fn set-title [title]{ print "\e]0;"$title"\e\\" }
    prompt_hooks:add-before-readline {
      set-title "elvish "(tilde-abbr $pwd) > /dev/tty
    }
    prompt_hooks:add-after-readline [cmd]{
      set-title (re:split '\s' $cmd | take 1)" "(tilde-abbr $pwd)
    }
  #+END_SRC

* Miscellaneous stuff

  I use the [[https://atlas.oreilly.com/][O'Reilly Atlas]] publishing platform. The [[file:lib/atlas.org][atlas]] module
  contains some useful functions for triggering and accessing document
  builds.

  #+BEGIN_SRC elvish
    use atlas
  #+END_SRC

  The =private= module sets up some private settings such as
  authentication tokens. This is not on github :)

  #+BEGIN_SRC elvish
    if ?(test -f ~/.elvish/lib/private.elv) { use private }
  #+END_SRC

 I use the smart-matcher module from
 https://github.com/xiaq/edit.elv/blob/master/smart-matcher.elv, which
 tries prefix match, smart-case prefix match, substring match,
 smart-case substring match, subsequence match and smart-case
 subsequence match.

 For it to work, we need to install the smart-matcher module, which is
 hosted in github. The following code installs it if necessary:

  #+BEGIN_SRC elvish
    if (not ?(test -d ~/.elvish/lib/github.com/xiaq)) {
      mkdir -p ~/.elvish/lib/github.com/xiaq
      git clone https://github.com/xiaq/edit.elv.git ~/.elvish/lib/github.com/xiaq/edit.elv
    }
  #+END_SRC

 Now we can load and configure it.

  #+BEGIN_SRC elvish :noweb no-export
    use github.com/xiaq/edit.elv/smart-matcher
    edit:-matcher[''] = $smart-matcher:match~
  #+END_SRC

  Other possible values for =edit:-matcher= are =[p]{ edit:match-prefix
 &smart-case $p }= for smart-case completion (if your pattern is
 entirely lower case it ignores case, otherwise it's case sensitive).
 =&smart-case= can be replaced with =&ignore-case= to make it always
 case-insensitive.

  Some general environment variables.

  #+BEGIN_SRC elvish
    E:LESS = "-i -R"
    E:EDITOR = "vim"
    E:LC_ALL = "en_US.UTF-8"
  #+END_SRC

  Function to shorten a string to a maximum length, followed by dots.

  #+BEGIN_SRC elvish
    fn dotify_string [str dotify_length]{
      if (or (== $dotify_length 0) (<= (count $str) $dotify_length)) {
        put $str
      } else {
        re:replace '(.{'$dotify_length'}).*' '$1â€¦' $str
      }
    }
  #+END_SRC

  [[https://github.com/elves/elvish/issues/500][Parallel redirection of stdout and stderr to different commands]]. The
  =pipesplit= function takes three lambdas. The first one is executed,
  its stdout is redirected to the second one, and its stderr to the
  third one.

  #+BEGIN_SRC elvish
    fn pipesplit [l1 l2 l3]{
      pout = (pipe)
      perr = (pipe)
      run-parallel {
        $l1 > $pout 2> $perr
        pwclose $pout
        pwclose $perr
      } {
        $l2 < $pout
        prclose $pout
      } {
        $l3 < $perr
        prclose $perr
      }
    }
  #+END_SRC

 Example:

  #+BEGIN_EXAMPLE
    > pipesplit { echo stdout-test; echo stderr-test >&2 } { echo STDOUT: (cat) } { echo STDERR: (cat) }
    STDOUT: stdout-test
    STDERR: stderr-test
  #+END_EXAMPLE
